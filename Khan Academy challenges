-- tables may be nicknamed eg from table.charlotte tab
--/or/ command 
    SELECT title FROM songs WHERE mood = "epic" OR released >1990;
    --/ and/ command 
    SELECT title FROM songs WHERE mood = "epic" AND released > 1990 AND duration < 240
    
   SELECT * FROM exercise_logs WHERE type = "biking" OR type = "hiking" OR type = "tree climbing" OR type = "rowing";

/* IN */ is a shortcut or a neater way to write the querry above. type allows you to select individual items in a column 
/*NOT IN*/ does the inverse of the IN command, that is, what is not in ()
SELECT * FROM exercise_logs WHERE type IN ("biking", "hiking", "tree climbing", "rowing");
*insert new table*
SELECT type FROM drs_favorites;

/subqueries/ 
-can select items that are in both tables in common 
SELECT * FROM exercise_logs WHERE type IN (
    SELECT type FROM drs_favorites);
    
SELECT * FROM exercise_logs WHERE type IN (
    SELECT type FROM drs_favorites WHERE reason = "Increases cardiovascular health");
 
 -This functions allows you to shorten the name in the actual table to find the one word that is common in the sentence 
 - the use of % is necessary to represent a wildcard that allows the function to work 
/* LIKE */

SELECT * FROM exercise_logs WHERE type IN (
    SELECT type FROM drs_favorites WHERE reason LIKE "%cardiovascular%");
Math operators may be used at any point in sql 
Round function may also be used in sql 

/CASE/ function is used to create a new column 

/* 50-90% of max*/
SELECT COUNT(*) FROM exercise_logs WHERE
    heart_rate >= ROUND(0.50 * (220-30)) 
    AND  heart_rate <= ROUND(0.90 * (220-30));
    
/* CASE */
SELECT type, heart_rate,
    CASE 
        WHEN heart_rate > 220-30 THEN "above max"
        WHEN heart_rate > ROUND(0.90 * (220-30)) THEN "above target"
        WHEN heart_rate > ROUND(0.50 * (220-30)) THEN "within target"
        ELSE "below target"
    END as "hr_zone"
FROM exercise_logs;

SELECT COUNT(*) number_grade, 
CASE 
    WHEN number_grade >90 THEN "A"
    WHEN number_grade >80 THEN "B"
    WHEN number_grade >70 THEN "C"
    ELSE "F"
END as "letter_grade"
FROM student_grades
GROUP BY "letter_grade";

--/JOIN FUNCTION/
allows you to join data from different tables 
select *
(Specify the two tables)
FROM martian --"left table"
INNER JOIN base -- "right table" 
(Specify how to connect the tables)
ON martian.base_id = base.base_id; (martian and base are the table and base 
is the column id)

the two columns that you are joining are not always going to have the same names even if the numbers are common 
 
Once the new table has been created we can now write the following function 
SELECT first_name, last_name, base_name
FROM martian
INNER JOIN base 
ON martian.base_id= base.base_id;

--HOW TO INCLUDE ROWS THAT DO NOT HAVE A MATCH:
SELECT column1, column2,...
FROM martian
-----JOIN base
ON martian.base_id = base.base_id 
WHERE condition(s)
ORDER BY value 
  
 INNER JOIN - only returns connected,matching rows 
 LEFT JOIN - Returns all connected rows, and unconnected rows from left table (nulls in right)
 RIGHT JOIN - Returns all connected rows, and unconnected rows from right table (nulls in left)
 FULL JOIN - Returns connected rows & unconnected rows from both left and right tables
 my sql and sqllite do not support full joins 
 
 ** IMPORTANT TO SPECIFY BOTH COLUMN N TABLE NAME IN THE SELECT QUERY 
 SELECT martian(m).martian_id, base(b).base_id, base(b).base_name 
 FROM martian AS m (the as m makes it shorter to write the names)
 INNER JOIN base AS b 
 ON martian(m).base_id = base(b).base_id;

/* cross join */
-- not the most useful of joins
SELECT * FROM student_grades, students;

/* implicit inner join */
SELECT * FROM student_grades, students
    WHERE student_grades.student_id = students.id;
    
/* explicit inner join - JOIN */
-- best practice to use
--Important to specify the table that the column in from to avoid confusing the alg if in both tables there are columns with similar names
SELECT students.first_name, students.last_name, students.email, student_grades.test, student_grades.grade FROM students
    JOIN student_grades
    ON students.id = student_grades.student_id
    WHERE grade > 90;
    
 /* outer join */ 
SELECT students.first_name, students.last_name, student_projects.title
    FROM students (left table is after the from and right table is after the join)
    LEFT OUTER JOIN student_projects
    ON students.id = student_projects.student_id;
 This tells sql to keep the rows in the left table even if they do not match in the right table
 
 --EXAMPLE 
 Now, create another query that will result in one row per each customer, with their name, email, and total amount of money they've spent on orders. Sort the rows according to the total money spent, from the most spent to the least spent.
SELECT c.name, c.email, SUM(o.price) AS spent 
FROM customers as c 
LEFT OUTER JOIN orders as o 
ON c.id = o.customer_id 
GROUP BY c.name 
ORDER BY spent desc; 

/* self join */
SELECT students.first_name, students.last_name, buddies.email as buddy_email
    FROM students
    JOIN students buddies
    ON students.buddy_id = buddies.id;
    
buddies is an alias used when joining info within the same table 
buddies.id is the new table with the og id 

/*Combining multiple joins*/
SELECT a.title, b.title FROM project_pairs (the from section should be with the one that as the 2 datasets)
    JOIN student_projects a
    ON project_pairs.project1_id = a.id
    JOIN student_projects b
    ON project_pairs.project2_id = b.id;

CREATE TABLE artist (
    id INTEGER PRIMARY KEY AUTOINCREMENT, 
    name TEXT, age INTEGER); 
    
INSERT INTO artist (name, age) VALUES ("BTS", "25"); 
INSERT INTO artist (name, age) VALUES ("Rihanna", "34");
INSERT INTO artist (name, age) VALUES ("Emminem", "49");
INSERT INTO artist (name, age) VALUES ("DJ Khaled", "46");
INSERT INTO artist (name, age) VALUES ("J-Hope", "28");
INSERT INTO artist (name, age) VALUES ("Taylor Swift", "32");
INSERT INTO artist (name, age) VALUES ("INNA", "35");
INSERT INTO artist (name, age) VALUES ("Indila","38");
INSERT INTO artist (name, age) VALUES ("Madison Beer", "23");
INSERT INTO artist (name, age) VALUES ("Becky G", "25");

CREATE TABLE songs (
id INTEGER PRIMARY KEY AUTOINCREMENT, 
song_id INTEGER, title TEXT, release INTEGER);

INSERT INTO songs (song_id,title,release) VALUES (1,"Tomorrow","2014");
INSERT INTO songs (song_id,title,release) VALUES (2,"Monster","2013");
INSERT INTO songs (song_id,title,release) VALUES (3,"Monster","2013");

CREATE TABLE collab (
id INTEGER PRIMARY KEY AUTOINCREMENT, 
    artist1_id INTEGER, 
    artist2_id INTEGER, 
  song_id INTEGER); 
    
INSERT INTO collab (artist1_id, artist2_id, song_id) VALUES (2,3, 2); 
INSERT INTO collab (artist1_id, artist2_id, song_id) VALUES (2,4,1);

select a1.name,a2.name,s.title from collab
join artist a1 on a1.id=collab.artist1_id
join artist a2 on a2.id=collab.artist2_id 
join songs s on s.id = collab.song_id; 
  
  CREATE TABLE artist (
    id INTEGER PRIMARY KEY AUTOINCREMENT, 
    name TEXT, age INTEGER); 
    
INSERT INTO artist (name, age) VALUES ("BTS", "25"); 
INSERT INTO artist (name, age) VALUES ("Rihanna", "34");
INSERT INTO artist (name, age) VALUES ("Emminem", "49");
INSERT INTO artist (name, age) VALUES ("DJ Khaled", "46");
INSERT INTO artist (name, age) VALUES ("J-Hope", "28");
INSERT INTO artist (name, age) VALUES ("Taylor Swift", "32");
INSERT INTO artist (name, age) VALUES ("INNA", "35");
INSERT INTO artist (name, age) VALUES ("Indila","38");
INSERT INTO artist (name, age) VALUES ("Madison Beer", "23");
INSERT INTO artist (name, age) VALUES ("Becky G", "25");
INSERT INTO artist (name, age) VALUES ("Calvin Harris","38");
INSERT INTO artist (name, age) VALUES ("Ava Max","28");
INSERT INTO artist (name, age) VALUES ("Ellie Goulding","35");
INSERT INTO artist (name, age) VALUES ("Stromae","37");
INSERT INTO artist (name, age) VALUES ("Ed Sheeran","31");
INSERT INTO artist (name, age) VALUES ("The Weeknd","32");
INSERT INTO artist (name, age) VALUES ("Billie Eilish","20");

CREATE TABLE songs (
id INTEGER PRIMARY KEY AUTOINCREMENT, 
song_id INTEGER, title TEXT, release INTEGER, popularity INTEGER);

INSERT INTO songs (song_id,title,release, popularity) VALUES (1,"Tomorrow","2014",10);
INSERT INTO songs (song_id,title,release, popularity) VALUES (2,"Monster","2013",7);
INSERT INTO songs (song_id,title,release,popularity) VALUES (3,"Not Afraid","2010",9);
INSERT INTO songs (song_id,title,release,popularity) VALUES (4,"Wild Thoughts","2017",10);
INSERT INTO songs (song_id,title,release,popularity) VALUES (5,"Chicken Noodle Soup","2019",10);
INSERT INTO songs (song_id,title,release,popularity) VALUES (6,"Red","2012",7);
INSERT INTO songs (song_id,title,release,popularity) VALUES (7,"Amazing","2009",8);
INSERT INTO songs (song_id,title,release,popularity) VALUES (8,"Tourner dans le vide","2014",6);
INSERT INTO songs (song_id,title,release,popularity) VALUES (9,"Good in goodbye","2021",8); 
INSERT INTO songs (song_id,title,release,popularity) VALUES (10,"Shower","2014",4);
INSERT INTO songs (song_id,title,release,popularity) VALUES (11,"This is what you came for","2016",10);
INSERT INTO songs (song_id,title,release,popularity) VALUES (12,"Sweet but Psycho","2018",5);
INSERT INTO songs (song_id,title,release,popularity) VALUES (13,"Lights","2010",6);
INSERT INTO songs (song_id,title,release,popularity) VALUES (14,"Papaoutai","2013",10);
INSERT INTO songs (song_id,title,release,popularity) VALUES (15,"Perfect","2017",4);
INSERT INTO songs (song_id,title,release,popularity) VALUES (16,"Call out my name","2018",9);
INSERT INTO songs (song_id,title,release,popularity) VALUES (17,"Happier than ever","2021",3);
INSERT INTO songs (song_id,title,release,popularity) VALUES (18,"Love me like you do","2015",8);
INSERT INTO songs (song_id,title,release,popularity) VALUES (19,"Love the way you lie","2010",7);
INSERT INTO songs (song_id,title,release,popularity) VALUES (20,"Everything has changed","2013",7); 

CREATE TABLE collab (
id INTEGER PRIMARY KEY AUTOINCREMENT, 
    artist1_id INTEGER, 
    artist2_id INTEGER, 
  song_id INTEGER); 
    
INSERT INTO collab (artist1_id, artist2_id, song_id) VALUES (2,3,2); 
INSERT INTO collab (artist1_id, artist2_id, song_id) VALUES (2,4,4);
INSERT INTO collab (artist1_id, artist2_id, song_id) VALUES (5,10,5);
INSERT INTO collab (artist1_id, artist2_id, song_id) VALUES (2,11,11);
INSERT INTO collab (artist1_id, artist2_id, song_id) VALUES (6,15,20);
INSERT INTO collab (artist1_id, artist2_id, song_id) VALUES (13,11,18);
INSERT INTO collab (artist1_id, artist2_id, song_id) VALUES (2,3,19);

/*Cross join*/
SELECT * FROM artist,songs; 

/*outer join*/
SELECT artist.name,songs.title
FROM songs
LEFT OUTER JOIN artist
ON artist.id=songs.id;

/*Multiple joins*/
/* What artists collaborated on songs and what are the song titles?*/

SELECT a1.name,a2.name,s.title 
FROM collab
JOIN artist a1 ON a1.id=collab.artist1_id
JOIN artist a2 ON a2.id=collab.artist2_id 
JOIN songs s ON s.id = collab.song_id;

/*Who were the top 5 most popular artists?*/
